# 数値計算のためのCPU・GPU・TPU入門

CPU・GPU・TPUは、同じ「数値計算」を実行しているように見えても、得意とする計算構造とデータ移動の前提が大きく異なる計算資源である。したがって選択と最適化は、演算回数よりも「どこにデータがあり、どれだけ動かすか」を中心に考えるのが合理的である。

## 参考ドキュメント
1. S. Williams, A. Waterman, D. Patterson, Roofline: An Insightful Visual Performance Model for Multicore Architectures, 2009.  
   https://dl.acm.org/doi/10.1145/1498765.1498785  （著者版PDFの例：https://people.eecs.berkeley.edu/~kubitron/cs252/handouts/papers/RooflineVyNoYellow.pdf）
2. NVIDIA, CUDA C++ Programming Guide（最新版）  
   https://docs.nvidia.com/cuda/cuda-c-programming-guide/
3. Google Cloud, TPU v5p（日本語）  
   https://docs.cloud.google.com/tpu/docs/v5p?hl=ja

## 1. はじめに

本稿は、数値計算（科学技術計算・最適化・機械学習を含む）において、CPU・GPU・TPUがどのような計算モデルとメモリ階層を取り、どのような計算に強いかを、学術的に整合する概念（スループット、レイテンシ、演算集約度など）で説明するものである。  
単なる用語解説ではなく、計算を「演算」と「データ移動」に分解し、性能上限を見積もるための数式、比較表、精度設計の考え方、分散実行における通信モデルまでを含めて体系化する。

---

## 2. CPU・GPU・TPUの位置づけ

### 2.1 CPU（Central Processing Unit）
CPUは、分岐・不規則アクセス・複雑な制御を含む処理を低遅延に実行しやすい設計である。高性能計算では、多数コア化とSIMD（ベクトル化）によりスループットを増やすが、依然として「汎用性」と「制御の自在さ」が核である。

### 2.2 GPU（Graphics Processing Unit / GPGPU）
GPUは、多数のスレッドを同時に進めることで高スループットを得る設計である。単純に言えば、同じ形の計算を大量のデータへ一括適用する状況で真価を発揮する。行列演算、畳み込み、ベクトル化できる反復計算などに強い一方、分岐や不規則アクセスが増えると効率が落ちやすい。

### 2.3 TPU（Tensor Processing Unit）
TPUは、機械学習、とくに大規模行列演算（GEMMに代表される）を高効率に実行するために設計された専用アクセラレータである。内部にMXU（Matrix Multiply Unit）と呼ばれるシストリックアレイ型の行列積ユニットを持ち、高帯域メモリと専用の相互接続により大規模並列を前提にする。


## 3. 性能を決める二つの支配要因：演算とデータ移動

数値計算の実行時間は大雑把に、(i) 演算そのものに要する時間と、(ii) メモリ階層やデバイス間でデータを動かす時間の大きい方で決まると捉えられる。この考え方は、後述のRooflineモデルで定量化される。

### 3.1 演算スループット（ピーク性能）
演算性能は、理想的には
- 1サイクル当たりの演算数
- 動作周波数
- 並列実行単位の数（コア数、SIMD幅、SM数、MXU数など）

で決まる。ピーク性能（例：TFLOPS）は「上限」であり、実測性能はデータ移動や実行効率で下がる。

### 3.2 メモリ帯域とレイテンシ
メモリアクセスは、一般に
- レイテンシ（最初の1要素が届くまでの時間）
- 帯域（単位時間あたりに運べる量）

で特徴づけられる。近年の高性能計算では、帯域がボトルネックになりやすい。特に疎行列や不規則アクセスでは、帯域利用効率（有効帯域）が理論値より大きく低下しうる。


## 4. 計算モデルの違い

### 4.1 CPU：MIMDとSIMD
CPUは基本的にMIMD（Multiple Instruction, Multiple Data）であり、コアごとに別の命令系列を進められる。加えて各コアはSIMD命令により、同じ命令で複数要素を同時処理する。  
このためCPUは、
- 分岐が多い
- データ構造が複雑
- 小さなカーネルを頻繁に呼ぶ
といった状況でも性能が出やすい。

### 4.2 GPU：SIMT
GPUはSIMT（Single Instruction, Multiple Threads）として説明されることが多い。多数スレッドが束（ワープ等）として同じ命令を進め、データだけが異なる形で並列性を稼ぐ。  
分岐で同じ束の中のスレッドが別経路を選ぶと、逐次化が起きて有効スループットが落ちる。

### 4.3 TPU：Systolic
TPUは行列積を中心に据えた設計（Systolic）で、MXUが行列積の主要部分を担う。行列積が多いほど、計算資源が有効に埋まりやすい。逆に、行列積へ落ちにくい処理やFP64中心の計算は適合が難しくなりやすい。


## 5. メモリ階層とデータ配置

### 5.1 CPUのメモリ階層
- レジスタ
- L1 / L2 / L3キャッシュ（共有度は設計により異なる）
- DRAM（NUMA構成の場合はソケット間で到達コストが異なる）

CPUではキャッシュの局所性を作ることが効きやすい。局所性とは、近い時刻に近いアドレスを再利用する性質であり、連続走査やブロッキング（タイル化）で改善される。

### 5.2 GPUのメモリ階層
- レジスタ（スレッド単位）
- 共有メモリ（ブロック単位、オンチップで低遅延・高帯域）
- L2キャッシュ
- グローバルメモリ（HBM/GDDRなど、容量は大きいがオンチップより遅い）
- ホストメモリ（PCIe等を介するため相対的に遅い）

GPUでは、オンチップ資源（レジスタ・共有メモリ）でデータ再利用を作り、グローバルメモリの往復を減らす設計が要所になる。

### 5.3 TPUのメモリと相互接続
TPUでは高帯域メモリ（HBM）と、チップ間相互接続（ICI）を前提に大規模並列を実現する。モデル並列・データ並列が大きいほど効果が出やすい。


## 6. 性能上限を数式で掴む：Rooflineモデルと並列化則

### 6.1 Rooflineモデル（演算集約度）
演算集約度（operational intensity）は
$${I = \frac{\text{FLOPs}}{\text{Bytes moved}}}$$
で表される。ここで「Bytes moved」は、主としてボトルネックとなるメモリ階層（例：DRAM↔キャッシュ、HBM↔SM）との間で動く量である。

Rooflineモデルでは、到達可能性能 $P$（FLOP/s）は
$$P \le \min\left(P_{\text{peak}},\ B \cdot I\right)$$
と表される。$P_{\text{peak}}$ は演算ピーク性能、$B$ はメモリ帯域（Bytes/s）である。

解釈は単純である。
- $I$ が小さい（データ移動が多い）と $B \cdot I$ が支配し、帯域制約になる
- $I$ が大きい（演算が多い）と $P_{\text{peak}}$ が支配し、演算制約になる

### 6.2 Amdahlの法則（強いスケーリングの限界）
並列化できない割合を $s$、並列度を $N$ とすると、理想加速比 $S$ は
$$S(N)=\frac{1}{s+\frac{1-s}{N}}$$
で上限づけられる。GPUやTPUは $N$ が極めて大きいため、$s$ を極小にする設計（すなわち逐次部分の削減）がより重要になる。

### 6.3 Gustafsonの法則（弱いスケーリングの見方）
問題サイズを増やすと並列部が増える場合、別の見方として
$$S_{\text{G}}(N)=N-s(N-1)$$
が用いられる。実際の大規模計算（PDE、大規模学習）はこちらの見方が実態に近いことが多い。

### 6.4 通信コストの基本モデル
分散メモリ系（MPI、分散TPU/GPU）では、通信時間を
$$T_{\text{comm}} \approx \alpha + \beta \cdot n$$
と近似することが多い。$\alpha$ は起動遅延、$\beta$ は1バイトあたりコスト、$n$ は通信量である。集合通信（all-reduce等）は $n$ とトポロジに依存して増大するため、学習や反復法のスケーリングを左右する。


## 7. 計算パターン別の適性

数値計算は「何を計算するか」により、演算集約度やメモリアクセスが大きく異なる。以下では基本的なパターンを整理する。

### 7.1 密行列計算（GEMM、畳み込み）
- 特徴：高い演算集約度、規則的アクセス、ブロッキングが効く
- 適性：GPU・TPUが非常に強い。CPUも高性能だがスループットでは劣りやすい
- 理由：データ再利用を作りやすく、演算制約に寄せやすい

### 7.2 疎行列計算（SpMV、疎ソルバ）
- 特徴：演算集約度が低い、間接参照が多い、帯域制約になりやすい
- 適性：CPUが安定しやすい。GPUは工夫次第で大きく伸びるが、形式依存が強い
- 理由：不規則アクセスと低い $I$ により $B \cdot I$ 制約になりやすい

### 7.3 ステンシル計算（PDE格子、差分法、相場の離散化）
- 特徴：局所近傍アクセス、通信と境界処理が支配しやすい
- 適性：GPUが強いことが多い。CPUもキャッシュ設計次第で強い
- 留意：境界条件や分岐が増えるとSIMT効率が落ちる

### 7.4 FFT・スペクトル法
- 特徴：ストライドアクセスや転置が絡み、データ移動の比率が増えやすい
- 適性：GPUが強いことが多いが、転置・通信が支配する局面がある
- 近年：分散FFTではネットワークが支配要因になりやすい

### 7.5 モンテカルロ、サンプリング
- 特徴：独立試行が多ければ並列化しやすいが、乱数、分岐、収束判定が絡む
- 適性：試行が独立で単純ならGPUが強い。制御が複雑ならCPUが扱いやすい

### 7.6 機械学習（深層学習、拡散、LLM）
- 特徴：GEMM相当が支配し、混合精度が一般的である
- 適性：GPU・TPUが主戦場である。大規模学習では相互接続と集合通信が性能を左右する

## 8. 精度と数値安定性

### 8.1 浮動小数点と丸め誤差の基本
浮動小数点演算では、一般に
$$\mathrm{fl}(a \circ b) = (a \circ b)(1+\delta),\quad |\delta| \le u$$
と書けることが多い。$\circ$ は四則演算、$u$ は単位丸め誤差（machine epsilon）に関係する量である。多数の演算を足し込むと誤差が蓄積し、演算順序に依存する。

### 8.2 混合精度（Mixed Precision）の考え方
近年のGPU/TPUは、FP16やbfloat16を用いた行列演算を高速に実行し、加算（累積）をFP32で行う設計が一般的である。  
混合精度は、(i) 表現精度（丸め誤差）と (ii) 収束・安定性（最適化や線形ソルバの収束）の両方に影響するため、単に速い形式へ落とすだけでは不十分である。

設計の基本方針は次である。
- 行列積など大規模演算は低精度を活用しやすい
- 累積や正規化、確率の正規化などは高精度が必要になりやすい
- 数値が極端に小さい／大きい場合、スケーリング（例：損失スケーリング）が必要になる場合がある

### 8.3 bfloat16の性質（TPUで重要）
bfloat16は指数部を大きく取り、FP32と同等のダイナミックレンジを維持しつつ仮数部を短くした形式である。学習で重要な「桁あふれ・桁落ちの回避」を比較的保ちやすい一方、仮数が短いため細かな差分は表現しにくい。  
TPUでは、行列演算の入力をbfloat16、累積をFP32で行う設計が基本として提示されている。

### 8.4 再現性（決定性）の注意
並列化により和の順序が変わると結果が変わる場合がある。とくにGPU/TPUの大規模並列では、reduceや集合通信により演算順序が実行ごとに変動しうる。  
科学技術計算では、誤差許容と再現性要件（ビット一致が必要か、統計一致でよいか）を先に決めることが重要である。


## 9. 開発・実行環境の層（CPU・GPU・TPU）

ここでは、あくまで概念として「どの層が何を担うか」を整理する。例題コードは示さない。

### 9.1 CPU側の主要概念
- スレッド並列：OpenMPなど
- 分散並列：MPIなど
- ベクトル化：コンパイラ自動ベクトル化、SIMD指示
- 数値ライブラリ：BLAS/LAPACK、FFT、ソルバ群

CPUは既存の科学技術計算資産が豊富であり、移植性と再利用性が高い。

### 9.2 GPU側の主要概念
- カーネル実行モデル（スレッド束、ブロック、グリッド）
- メモリ空間の使い分け（グローバル、共有、定数など）
- ベンダ向けAPI：CUDA（NVIDIA）、HIP/ROCm（AMD）
- 互換・移植層：SYCL（oneAPI DPC++など）
- 数値ライブラリ：BLAS/FFT/乱数/ソルバ（CUDA/ROCmに対応）

GPUでは、オンチップ資源の活用とデータ配置が性能に直結しやすい。

### 9.3 TPU側の主要概念
- XLA（Accelerated Linear Algebra）によるコンパイル最適化
- PJRT（Uniform Device API）に基づく実行時接続
- 利用フレームワーク：JAX、PyTorch/XLA、TensorFlowなど
- 計算の中心：行列積を核とするテンソル演算

TPUでは、行列演算へ整形し、コンパイラが最適化しやすい中間表現（StableHLO等）へ落とすことが重要になる。


## 10. CPU・GPU・TPUの比較表

### 10.1 ハードウェア観点

| 観点 | CPU | GPU | TPU |
|---|---|---|---|
| 設計の中心 | 低遅延・汎用制御 | 高スループットSIMT | 行列演算中心（MXU） |
| 得意な計算 | 分岐、複雑制御、疎構造 | 密な並列、行列・畳み込み | 大規模テンソル演算 |
| 苦手になりやすい計算 | 超大規模同形演算の純スループット | 分岐過多・不規則アクセス | FP64中心・非テンソル優位 |
| メモリ階層の要点 | キャッシュ局所性、NUMA | 共有メモリ/レジスタ活用 | HBM＋ICI、コンパイル最適化 |
| スケールの前提 | ノード内強化＋MPI | ノード内大量並列＋分散 | 大規模並列前提（Pod等） |

### 10.2 ソフトウェア観点

| 観点 | CPU | GPU | TPU |
|---|---|---|---|
| 並列モデル | OpenMP, MPI | CUDA, HIP, SYCL | XLA, PJRT |
| 主な実行系 | OS上のプロセス/スレッド | ホスト＋デバイス | コンパイル＋デバイス |
| ライブラリ最適化 | BLAS/FFT/ソルバ | cuBLAS/rocBLAS等 | XLA最適化、フレームワーク統合 |
| 典型（基本）な制約 | メモリ帯域・NUMA | メモリ帯域・分岐・転送 | 行列化のしやすさ・精度形式 |


## 11. 目的別の選び方

選択は「どの制約を引き受けるか」の問題である。以下は判断軸である。

### 11.1 演算集約度 $I$ を見積もる
Rooflineの式 $P \le \min(P_{\text{peak}}, B I)$ を用い、対象カーネルが帯域制約か演算制約かをまず分類する。  
- $I$ が小さいなら、GPU/TPUへ移しても伸びが限定的になりうる  
- $I$ を上げられる（再利用を増やせる）なら、GPU/TPUの恩恵が大きい

### 11.2 分岐・不規則アクセスの多さを分類する
- 分岐が多い、データ構造が複雑：CPUが扱いやすい  
- 形が揃った大規模演算：GPU/TPUが伸びやすい

### 11.3 精度要件を先に固定する
- FP64が必須：CPU/GPU（HPC向けGPU）  
- 混合精度が許容：GPU/TPUが有利  
- 統計的収束が目的：低精度でも許容される場合がある

### 11.4 分散時の通信の比率を評価する
集合通信や転置が支配する場合、デバイスの演算性能を上げても全体が伸びないことがある。  
したがって、
- 1ステップあたりの通信量
- 同期頻度
- トポロジ（GPU間、TPU間、ノード間）
を評価して、計算と通信の釣り合いを取る必要がある。


## 12. 計測と検証

高速化は「正しさを保ったまま上限に近づける」行為である。したがって、次の二つを分けて扱う必要がある。
- 数値の正しさ：基準解との誤差、収束性、保存則（必要なら）
- 性能の正しさ：帯域・スループット・並列効率・通信時間の内訳

性能側は、Rooflineの枠組みで
- 実効帯域（GB/s）
- 実効演算性能（GFLOP/s）
を取り、どちらが支配しているかを確認するのが基本である。


## 13. まとめと展望

CPU・GPU・TPUの差は、単なる速さの差ではなく、計算を成立させる前提（並列実行モデル、メモリ階層、最適化の担い手）が異なる点にある。数値計算の設計は、演算回数の削減だけでなく、演算集約度 $I$ を意識してデータ移動を抑え、通信と同期を含めた全体の上限を数式で掴むことが要である。  

今後は、CPU/GPU/TPUの境界が「単体デバイスの違い」から「コンパイラと中間表現（例：XLA/StableHLO）を介した統合最適化」へ移り、同一アルゴリズムを複数ハードウェアへ写像する重要性が増すと見込まれる。その際、数値解析の観点（誤差・安定性・再現性）と、アーキテクチャ観点（帯域・通信・並列効率）を統合して設計できる人材と文書体系が、計算科学の競争力を左右する基盤になるはずである。

### 参考文献

- Google Cloud, TPU v5e（日本語）  
  https://docs.cloud.google.com/tpu/docs/v5e?hl=ja

- Google Cloud, TPU のアーキテクチャ（日本語）  
  https://docs.cloud.google.com/tpu/docs/system-architecture-tpu-vm?hl=ja

- Google Cloud, bfloat16の説明  
  https://docs.cloud.google.com/tpu/docs/bfloat16

- OpenXLA, XLA overview  
  https://openxla.org/xla

- JAX documentation, About / XLA・PJRTに関する説明  
  https://docs.jax.dev/en/latest/about.html

- PyTorch/XLA documentation, TPU accelerator  
  https://docs.pytorch.org/xla/master/accelerators/tpu.html

- Google Cloud Blog（日本語）, Cloud TPU v5p/v5eに関する紹介記事  
  https://cloud.google.com/blog/ja/products/ai-machine-learning/introducing-cloud-tpu-v5p-and-ai-hypercomputer

- AMD ROCm, HIP documentation / programming model  
  https://rocm.docs.amd.com/projects/HIP/  
  https://rocm.docs.amd.com/en/latest/how-to/programming_guide.html

- Intel, oneAPI DPC++/C++ Compiler Documentation  
  https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler-documentation.html

- OpenMP 5.2 日本語クイックリファレンス（PDF）  
  https://www.openmp.org/wp-content/uploads/OpenMPRef-5.2-1121-JA.pdf

- Fujitsu, Supercomputer Fugaku specifications（HBM2帯域など）  
  https://www.fujitsu.com/global/about/innovation/fugaku/specifications/

- 理化学研究所（講習資料）, CUDAプログラミング入門（日本語PDF）  
  https://i.riken.jp/wp-content/uploads/2015/06/secure_4467_cuda-programming_main.pdf
